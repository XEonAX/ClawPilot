.NET AI Assistant Frameworks and Projects
There are a few emerging .NET frameworks for building AI agents. For example, BotSharp is an open‐source C#/.NET Core AI bot platform that provides multi-agent conversation, state management, RAG (vector memory) support, and connectors to many LLMs and channels[1][2]. It even includes a TelegramBots plugin for Telegram integration[2][3]. Similarly, LLM Tornado is a provider-agnostic .NET SDK for AI agents, with 30+ built‐in connectors (including OpenRouter) and orchestration primitives[4][5]. (It can plug into Microsoft’s Semantic Kernel and supports local inference too.) In practice, you can either use one of these frameworks as a base or build a custom agent using lighter-weight libraries.
Apart from full frameworks, Microsoft Semantic Kernel (SK) is a popular .NET library for orchestration: it lets you call any LLM and manage memory with pluggable stores. SK supports LLM chains, function skills, and can use SQLite for memory[6][7]. (In fact SK provides a “SQLite Vector Store” connector for embeddings[7], see below.) Using SK you can hand-craft an assistant loop and use SK’s memory system on top of SQLite.
LLM Access via OpenRouter in .NET
OpenRouter exposes a unified LLM API compatible with OpenAI’s format. Any HTTP client in .NET will work. For example, you can POST to https://openrouter.ai/api/v1/chat/completions with an Authorization: Bearer <OPENROUTER_API_KEY> header[8]. In practice you could use the official OpenAI .NET SDK with its base URL overridden (e.g. set baseURL = "https://openrouter.ai/api/v1" and the API key) as shown in OpenRouter’s docs[9]. Alternatively, community SDKs exist: for instance OpenRouter.NET provides a modern C# client with strongly‐typed ChatCompletion and Tools support[10]. (One can instantiate an OpenRouterClient("YOUR_KEY") and call CreateChatCompletionAsync on it.) Another approach is to use a generic REST client like ServiceStack’s JsonApiClient pointed at https://openrouter.ai/api/v1/…[8]. In summary, the .NET options for LLM calls include using OpenRouter’s REST API directly or a wrapper library (e.g. OpenRouter.NET or the OpenAI .NET library with a custom base URL)[8][10].
SQLite for State and Vector Memory
For persistence, you can use SQLite as your on-disk store. Simple conversation history and user state can be stored in regular tables (e.g. via Microsoft.Data.Sqlite or Entity Framework Core). For vector-based memory (semantic retrieval), there are now built-in options in .NET: for example, the Semantic Kernel team provides a SQLite Vector Store connector. You can add the NuGet package Microsoft.SemanticKernel.Connectors.SqliteVec and register it in DI (e.g. builder.Services.AddSqliteVectorStore(...))[7]. This connector transparently maps your C# record fields to SQLite tables and stores embeddings in a vec_ virtual table for k-NN search[7][11]. Under the hood it can leverage the new sqlite-vec extension (which adds native vector types and kNN queries) or similar tech. In fact, sqlite-vec lets you treat SQLite as a vector database (with built-in KNN and SIMD-accelerated distance functions)[12][13]. Thus, one pattern is: use SK’s SQLite connector for storing embeddings in SQLite, or manually use sqlite-vec by creating a VIRTUAL TABLE on your .db. In either case, you get an embedded, file-based vector store. (If you prefer a separate vector database, BotSharp and Tornado also support Qdrant, Pinecone, etc.[2][14].)
Telegram Bot Integration in .NET
To communicate with you via Telegram, use a .NET Telegram Bot API library. The standard choice is Telegram.Bot, the official .NET client for Telegram bots[15]. It supports polling or webhooks and all message types. For example, you install the Telegram.Bot NuGet package, create a TelegramBotClient with your bot token, and set up an update handler or webhook endpoint to process incoming messages. The Telegram.Bot documentation provides quickstarts for console apps (long polling) or ASP.NET webhooks[16]. BotSharp’s Telegram plugin actually uses this library under the hood, which shows its reliability.
When a message arrives, you’ll typically normalize it into your agent’s format and enqueue it for processing (the “Gateway” layer). In complex systems (like OpenClaw) a gateway decouples transport from agent logic[17]. For a personal assistant, you can simply handle each update in a single session. The Telegram.Bot library lets you easily send replies or initiate “typing…” notifications.
Recommended Architectures & Libraries
Putting it all together, here are some concrete options:
Use a Full Framework (BotSharp or LLM Tornado). Both BotSharp and LLM Tornado provide an end-to-end solution. For example, with BotSharp you could configure the TelegramBots plugin and point its LLM provider to OpenRouter (via BotSharp’s OpenAI plugin using the OpenRouter base URL). You can store state in SQLite by writing a custom plugin or using SK via BotSharp’s SK plugin[2][7]. Alternatively, LLM Tornado has built-in OpenRouter support and can use Microsoft.Extensions.AI (SK) for memory[4][18]. These frameworks handle the agent loop, so you focus on configuring tools and prompts.
Use Semantic Kernel with Custom Code. You could build your own assistant loop using SK. For example, use SK’s ChatCompletion support to call OpenRouter, and SK memory to persist SQLite-based memory. In this case you’d write a small .NET console or service that uses SK’s Kernel to send/receive with the LLM. SK can store chat history and embeddings in SQLite (via SqliteCollection/SqliteVectorStore[7]) and perform hybrid search on memory. You’d handle Telegram messages with Telegram.Bot and feed them into SK. This gives flexibility at the cost of more coding.
Do It Manually (Minimal Stack). At minimum, use the Telegram.Bot library to receive messages and respond. Inside your message handler, call the OpenRouter API (e.g. with HttpClient or OpenRouterClient) to get completions. Manage state yourself: for example, use a SQLite table to log conversations or user data (using System.Data.SQLite). For embedding memory, either use SK’s SQLite connector or manually use sqlite-vec via SQL queries. This “roll-your-own” approach is lightweight but requires implementing context management, prompt building, and any chaining or tool calling yourself.
In summary, there’s no single official “.NET Claw,” but libraries like BotSharp or LLM Tornado can jump-start development. Otherwise, a typical architecture is: Gateway (Telegram.Bot) → Agent Loop (C# orchestrator with OpenRouter calls) → Persistence (SQLite for history + vector memory). This mirrors the hub-and-spoke pattern used by OpenClaw and its successors[17]. Depending on how much you want out-of-the-box functionality versus control, you can pick a full framework or assemble individual components (OpenRouter.NET or HttpClient, SK/SQLite, Telegram.Bot) to suit your needs[8][7].
Sources: BotSharp docs and GitHub[1][2]; OpenRouter docs[8]; Telegram.Bot docs[15]; Semantic Kernel SQLite connector docs[7]; sqlite-vec article[12]; LLM Tornado GitHub[19][4].

[1] [2] [3] GitHub - SciSharp/BotSharp: AI Multi-Agent Framework in .NET
https://github.com/SciSharp/BotSharp
[4] [5] [14] [18] [19] GitHub - lofcz/LLMTornado: The .NET library to build AI agents with 30+ built-in connectors.
https://github.com/lofcz/LLMTornado
[6] GitHub - microsoft/semantic-kernel: Integrate cutting-edge LLM technology quickly and easily into your apps
https://github.com/microsoft/semantic-kernel
[7] [11] Using the Semantic Kernel SQLite Vector Store connector (Preview) | Microsoft Learn
https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/out-of-the-box-connectors/sqlite-connector
[8] [9] OpenRouter Quickstart Guide | Developer Documentation | OpenRouter | Documentation
https://openrouter.ai/docs/quickstart
[10] GitHub - WilliamAvHolmberg/OpenRouter.NET: Modern .NET SDK for the OpenRouter API - unified access to Claude, GPT, Gemini, and more
https://github.com/WilliamAvHolmberg/OpenRouter.NET
[12] [13] How sqlite-vec Works for Storing and Querying Vector Embeddings | by Stephen Collins | Medium
https://medium.com/@stephenc211/how-sqlite-vec-works-for-storing-and-querying-vector-embeddings-165adeeeceea
[15] GitHub - TelegramBots/Telegram.Bot: .NET Client for Telegram Bot API
https://github.com/TelegramBots/Telegram.Bot
[16] Introduction - A guide to Telegram.Bot .NET library
https://telegrambots.github.io/book/
[17] OpenClaw, NanoBot, PicoClaw, IronClaw, ZeroClaw, NullClaw: This *Claw Craziness Is Continuing… | by evoailabs | Feb, 2026 | Medium
https://evoailabs.medium.com/openclaw-nanobot-picoclaw-ironclaw-and-zeroclaw-this-claw-craziness-is-continuing-87c72456e6dc